# Data Encryption Standard (DES)

In 1973 the National Bureau of Standards (NBS), the predecessor to the NIST, issued a public request for researchers and corporations to submit an algorithm that could serve as a standard method for encryption.  This request came at a time when encryption was being implemented but not in a standard fashion.  Digital networks and computers were becoming more common and so there was a need to have one standard encryption scheme.  The new standard was to be named the **Data Encryption Standard**.

## LUCIFER

A researcher at IBM named Horst Feistel created and refined a series of block ciphers during 1971 that was labelled LUCIFER.  Corporations often have an incentive to drive the direction of standards and so IBM submitted LUCIFER to the NSB as a candidate for DES.  The National Security Agency (NSA) has always maintained a staff of high caliber mathematicians and was asked to review LUCIFER.  The NSA proposed some modifications which included reducing the key size from 128 bits to 56 bits.  It was claimed the 128 bit key might reduce performance.  

LUCIFER implemented an algorithm that entailed 16 rounds of something known as a Fiestel structure.  The NSA made a few modifications to strengthen LUCIFER.  

In 1977, IBM's LUCIFER and the modifications were accepted as the NSB's Data Encryption Standard and published in Publication 46 of the Federal Information Processing Standard (FIPS).

## Conspiracies

Many researchers voiced concerns about the NSA's modifications and recommendations.  There were fears the NSA may have implemented a **trap door** into the DES algorithm allowing it to decrypt sensitive data.  Later publications, some mentioned in RFC 4772 (2006), demonstrated that IBM was aware LUCIFER might be vulnerable to some differential cryptoanalsys attacks.  Despite the conspiracy theories, DES became the first government approved encryption standard in 1977.  RFC 4772 (published 2006) indicates it was still around as a legacy system in the early 2000s.  During the early 1990's a variation of DES was widely used and was known as **Triple DES (3DES)**.  NIST publication 800-67 and FIPS 46-3 standardized 3DES in the late 1990's.  

The NIST (formerly NSB) issued a new request for comments to establish an **Advanced Encryption Standard (AES)**.  The call was answered and in 2001 an algorithm was accepted and standardized as the **AES** and was incorporated into FIPS.

## DES & 3DES Deprecated

Below is a rough historical timeline of how DES and 3DES was deprecated and removed from FIPS 

* 1999 - FIPS Publication 46-3 deprecated DES and suggested the use of 3DES as an alternative. 
* 2001 - AES was identified as a far superior encryption algorithm was adopted as a standard in FIPS Publication 197.
* 2017 - NIST Special Publication 800-131A deprecated 3DES.  This meant it should not be used for new applications requiring encryption.   However, new applications could incorporate 3DES in order to decrypt existing data.  Afterall, 3DES had been used for at least two decades and 3DES encrypted documents lingered.
* 2019 - NIST Special Publication 800-131A Revision 1 reaffirmed the deprecation of 3DES.
* 2023 - NIST removed DES and 3DES from FIPS 140-3 Annex A (Cryptographic Modules). This meant DES and 3DES could not longer be implemented in any applications for the federal government. 

DES is very difficult to demonstrate manually.  However, it is relatively simple to understand on a high-level.  It has tremendous historical importance and people wanting careers in the computing industry should be familar with the story of DES.

## DES Algorithm

The DES algorithm has the following stages.

1. 64 bit blocks of the original plaintext message are used as inputs. 
2. There is an initial permutation on the bits. Essentially a static swapping of the bits. 
3. The 64 permuted bits are partitioned into two groups known as the Left and Right partitions. 
4. Both Left and Right halves have 16 rounds Fiestel iterations applied using the encryption key.
5. The two halves are combined and a final permutation applied to the bits.
6. The result is a 64 bit block of ciphertext


### Initial Permutation Stage 

The plaintext is partitioned into 64 bit blocks. A static permutation is applied to each plaintext block.  The matrix $P$ below represents the initial permutation in functional form. Let $B_i$ be the $i$th bit position in the 64 bit block (zero being first index).  The permutation matrix indicates that the bit in coordinate $8 \cdot (i-1) + (j-1)$ should be swapped with the bit in position $(P_{i,j} -1$ ($i$th row and $j$th column of matrix P).

$$
P = \begin{bmatrix}
58 & 50 & 42 & 34 & 26 & 18 & 10 & 2 \\
60 & 52 & 44 & 36 & 28 & 20 & 12 & 4 \\
62 & 54 & 46 & 38 & 30 & 22 & 14 & 6 \\
64 & 56 & 48 & 40 & 32 & 24 & 16 & 8 \\
57 & 49 & 41 & 33 & 25 & 17 &  9 & 1 \\
59 & 51 & 43 & 35 & 27 & 19 & 11 & 3 \\
61 & 53 & 45 & 37 & 29 & 21 & 13 & 5 \\
63 & 55 & 47 & 39 & 31 & 23 & 15 & 7
\end{bmatrix}
$$

Remember we are implementing bitwise swaps on a 64bit array. Below is a bitwise function to accomplish this task. 

    uint64_t initial_bit_perm = 0;

    static const char IP[64] = {
        58, 50, 42, 34, 26, 18, 10,  2, 
        60, 52, 44, 36, 28, 20, 12,  4, 
        62, 54, 46, 38, 30, 22, 14,  6, 
        64, 56, 48, 40, 32, 24, 16,  8, 
        57, 49, 41, 33, 25, 17,  9,  1, 
        59, 51, 43, 35, 27, 19, 11,  3, 
        61, 53, 45, 37, 29, 21, 13,  5, 
        63, 55, 47, 39, 31, 23, 15,  7
    };

    for (i = 0; i < 64; i++) {
        initial_bit_perm <<= 1;  //shift elements to left to add new LSB 
        initial_bit_perm |= (initial_bit_block >> (64-IP[i])) & 1; //add new LSB 
    }

The C code snippet above basically does the following for each iteration of $i$:

1. Description of variables
    * **initial_bit_block** is a 64 bit plaintext message block represented as a **uint64_t** typed variable.
    * **IP** is the initial permutation map.
    * **initial_bit_perm** will be the result of the **initial_bit_block** after the permutation map **IP** has been applied to it.
2. The **for loop**
    * Each iteration of the loop will update the result **initial_bit_perm** one bit at a time. 
        * Each update will add a new bit in the **least significant bit (LBS)** position (right-most position).
        * At the start of each iteration the bits of **initial_bit_perm** are left-shifted by one bit.  This preserves the result and makes the far right (LSB) bit zero. Effectively this makes room for the new bit the iteration will create.
    * The **OR EQUAL** operator expression
        * The LSB will be flipped to **1** or kept **0** based on the result of the expression on the right of the **OR EQUAL** operator. 
        * The expression to apply the initial permutation does the following
            * Shifts the bits of the original plaintext message block by the value found in the $i$th position of the **IP** array. 
            * The bit in the LSB position (plaintext block) after shifting is determined using the AND boolean operation and the number 1. This results in a 64 bit value where all bits are zero except for potentially the last bit (LSB).  The LSB of this 64 bit array 


The effect is to construct bit by bit the permuted bit value. 

Once the bits of the plaintext block have been permuted the bits are split into two equal parts. 

