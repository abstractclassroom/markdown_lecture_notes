# Data Encryption Standard (DES)

In 1973 the National Bureau of Standards (NBS), the predecessor to the NIST, issued a public request for researchers and corporations to submit an algorithm that could serve as a standard method for encryption.  This request came at a time when encryption was being implemented but not in a standard fashion.  Digital networks and computers were becoming more common and so there was a need to have one standard encryption scheme.  The new standard was to be named the **Data Encryption Standard**.

## LUCIFER

A researcher at IBM named Horst Feistel created and refined a series of block ciphers during 1971 that was labelled LUCIFER.  Corporations often have an incentive to drive the direction of standards and so IBM submitted LUCIFER to the NSB as a candidate for DES.  The National Security Agency (NSA) has always maintained a staff of high caliber mathematicians and was asked to review LUCIFER.  The NSA proposed some modifications which included reducing the key size from 128 bits to 56 bits.  It was claimed the 128 bit key might reduce performance.  

LUCIFER implemented an algorithm that entailed 16 rounds of something known as a Fiestel structure.  The NSA made a few modifications to strengthen LUCIFER.  

In 1977, IBM's LUCIFER and the modifications were accepted as the NSB's Data Encryption Standard and published in Publication 46 of the Federal Information Processing Standard (FIPS).

## Conspiracies

Many researchers voiced concerns about the NSA's modifications and recommendations.  There were fears the NSA may have implemented a **trap door** into the DES algorithm allowing it to decrypt sensitive data.  Later publications, some mentioned in RFC 4772 (2006), demonstrated that IBM was aware LUCIFER might be vulnerable to some differential cryptoanalsys attacks.  Despite the conspiracy theories, DES became the first government approved encryption standard in 1977.  RFC 4772 (published 2006) indicates it was still around as a legacy system in the early 2000s.  During the early 1990's a variation of DES was widely used and was known as **Triple DES (3DES)**.  NIST publication 800-67 and FIPS 46-3 standardized 3DES in the late 1990's.  

The NIST (formerly NSB) issued a new request for comments to establish an **Advanced Encryption Standard (AES)**.  The call was answered and in 2001 an algorithm was accepted and standardized as the **AES** and was incorporated into FIPS.

## DES Deprecated

Below is a rough historical timeline of how DES and 3DES was deprecated and removed from FIPS 

* 1999 - FIPS Publication 46-3 deprecated DES and suggested the use of 3DES as an alternative. 
* 2001 - AES was identified as a far superior encryption algorithm was adopted as a standard in FIPS Publication 197.
* 2017 - NIST Special Publication 800-131A deprecated 3DES.  This meant it should not be used for new applications requiring encryption.   However, new applications could incorporate 3DES in order to decrypt existing data.  Afterall, 3DES had been used for at least two decades and 3DES encrypted documents lingered.
* 2019 - NIST Special Publication 800-131A Revision 1 reaffirmed the deprecation of 3DES.
* 2023 - NIST removed DES and 3DES from FIPS 140-3 Annex A (Cryptographic Modules). This meant DES and 3DES could not longer be implemented in any applications for the federal government. 

DES is very difficult to demonstrate manually.  However, it is relatively simple to understand on a high-level.  It has tremendous historical importance and people wanting careers in the computing industry should be familar with the story of DES.

## DES Algorithm

The DES algorithm has the following stages.

1. 64 bit blocks of the original plaintext message are used as inputs. 
2. There is an initial permutation on the bits. Essentially a static swapping of the bits. 
3. The 64 permuted bits are partitioned into two groups known as the Left and Right partitions. 
4. Both Left and Right halves have 16 rounds Fiestel iterations applied using the encryption key.
5. The two halves are combined and a final permutation applied to the bits.
6. The result is a 64 bit block of ciphertext


### Initial Permutation Stage 

The plaintext is partitioned into 64 bit blocks. A static permutation is applied to each plaintext block.  The matrix $P$ below represents the initial permutation in functional form. 

$$
\begin{align}
P = (&\\
&58 , 50 , 42 , 34 , 26 , 18 , 10 , 2, \\
&60 , 52 , 44 , 36 , 28 , 20 , 12 , 4, \\
&62 , 54 , 46 , 38 , 30 , 22 , 14 , 6, \\
&64 , 56 , 48 , 40 , 32 , 24 , 16 , 8, \\
&57 , 49 , 41 , 33 , 25 , 17 ,  9 , 1, \\
&59 , 51 , 43 , 35 , 27 , 19 , 11 , 3, \\
&61 , 53 , 45 , 37 , 29 , 21 , 13 , 5, \\
&63 , 55 , 47 , 39 , 31 , 23 , 15 , 7 \\
&)
\end{align}
$$

Below provides a quick example of how to use the initial permutation map $P$.

* The bit in position 1 gets swapped with the bit in position 58.
* The bit in position 2 gets swapped with the bit in position 50.
* The bit in position 3 gets swapped with the bit in position 42.
* etc 

Remember we are implementing bitwise swaps on a 64bit array. Below is a bitwise function to accomplish this task. 

    uint64_t initial_bit_perm = 0;

    static const char IP[64] = {
        58, 50, 42, 34, 26, 18, 10,  2, 
        60, 52, 44, 36, 28, 20, 12,  4, 
        62, 54, 46, 38, 30, 22, 14,  6, 
        64, 56, 48, 40, 32, 24, 16,  8, 
        57, 49, 41, 33, 25, 17,  9,  1, 
        59, 51, 43, 35, 27, 19, 11,  3, 
        61, 53, 45, 37, 29, 21, 13,  5, 
        63, 55, 47, 39, 31, 23, 15,  7
    };

    for (i = 0; i < 64; i++) {
        initial_bit_perm <<= 1;  //shift elements to left to add new LSB 
        initial_bit_perm |= (initial_bit_block >> (64-IP[i])) , 1; //add new LSB 
    }

The C code snippet above basically does the following for each iteration of $i$:

1. Description of variables
    * **initial_bit_block** is a 64 bit plaintext message block represented as a **uint64_t** typed variable.
    * **IP** is the initial permutation map.
    * **initial_bit_perm** will be the result of the **initial_bit_block** after the permutation map **IP** has been applied to it.
2. The **for loop**
    * Each iteration of the loop will update the result **initial_bit_perm** one bit at a time. 
        * Each update will add a new bit in the **least significant bit (LBS)** position (right-most position).
        * At the start of each iteration the bits of **initial_bit_perm** are left-shifted by one bit.  This preserves the result and makes the far right (LSB) bit zero. Effectively this makes room for the new bit the iteration will create.
    * The **OR EQUAL** operator expression
        * The LSB will be flipped to **1** or kept **0** based on the result of the expression on the right of the **OR EQUAL** operator. 
        * The expression to apply the initial permutation does the following
            * Shifts the bits of the original plaintext message block by the value found in the $i$th position of the **IP** array. 
            * The bit in the LSB position (plaintext block) after shifting is determined using the AND boolean operation and the number 1. This results in a 64 bit value where all bits are zero except for potentially the last bit (LSB).  The LSB of this 64 bit array 


The effect is to construct bit by bit the permuted bit value. 

Once the bits of the plaintext block have been permuted the bits are split into two equal parts.  


### Expander Maps 

The DES algorithm splits the permuted bits into two 32-bit partitions. The right half of the split must be expanded from 32 bits to 48 bits.  An expander map $E$ is used to perform this action and is provided as an array below.

$$
\begin{align}
E = (&\\
    &32,  1,  2,  3,  4,  5,  \\
     &4,  5,  6,  7,  8,  9,  \\
     &8,  9, 10, 11, 12, 13, \\
    &12, 13, 14, 15, 16, 17, \\
    &16, 17, 18, 19, 20, 21, \\
    &20, 21, 22, 23, 24, 25, \\
    &24, 25, 26, 27, 28, 29, \\
    &28, 29, 30, 31, 32,  1\\
&)
\end{align}
$$

The array $E$ has 48 entries filled with values from 1 to 32.  Below outlines the expansion algorithm. 

* Create an empty 48 bit array (potentially a 64 bit array and only use 48 LSB portion)
* Let $b = E_i$ (value in the $i$ coordinate of array $E$). 
    * The $i$th entry in the new 48 bit array will be value in the $b$ coordinate of the original 32 bit array.

Below is a C bit implementation of this expansion.

    uint64_t expanded_rhs = 0;
    for (j = 0; j< 48; j++) {
        expanded_rhs <<= 1;
        expanded_rhs |= (uint64_t) ((right >> (32-E[j])) & 1);
    }

Below is a description of the operation of the expansion code. 

* **expanded_rhs** will be the 48 bit expanded version of the right-hand side of permuted bits. 
    * The 48 bit value will be created one bit at a time. 
    * The operator **<<=** shifts the array to the left one bit to make room for the new bit in the LSB position.
* The **right** hand side of the permuted bits are analyzed one bit at a time.
    * The right hand side (rhs) bits are shifted to the right to make the bit found in the table in the LSB position. 
    * AND operation with the LSB determines whether the bit position is a 1 or a 0.
* The **or equal** operation updates the new zero in the LSB position of the 48 bit array to match the LSB position of shifted (by expansion map) right hand side bits. 


### Key Schedule processes 

DES uses a key that is 64 bits long. However, only 56 of the bits are used because every 8th bit is a parity checksum bit.  Similar to how the initial permutation and expander maps operate, the **Permutated Choice 1 (PC1)** map permutes the bits and removes the 8 parity bits.   The PC1 map is provided below. 

$$
\begin{align}
PC1 = (& \\
    &57, 49, 41, 33, 25, 17,  9, \\
    & 1, 58, 50, 42, 34, 26, 18, \\
    &10,  2, 59, 51, 43, 35, 27, \\
    &19, 11,  3, 60, 52, 44, 36, \\
    &63, 55, 47, 39, 31, 23, 15, \\
    & 7, 62, 54, 46, 38, 30, 22, \\ 
    &14,  6, 61, 53, 45, 37, 29, \\
    &21, 13,  5, 28, 20, 12,  4 \\
&)
\end{align}
$$

The resuling 56 bit array is partitioned into two 28 bit arrays. This can be accomplished using bit masks as shown below. 

    left_28 = (uint32_t) ((permuted_choice_1 >> 28) & 0x000000000fffffff);
    right_28 = (uint32_t) (permuted_choice_1 & 0x000000000fffffff);


The two 28 bit arrays are passed through 16 **fiestel** rounds where the bits will be rotated (left shifts with edge bits carrying over to the LSB position). The number of shifts depend on the round number but are generally 1 to 2 rotations per round. 

The **shift map** below has 16 entries and determines how many shifts will happen on the $i$th round of the 16 rounds.

$$shift_map = (1,  1,  2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  1)$$

The bit implementation to represent 


### S-Boxes 

There are 8 s-boxes found in the DES algorithm. 