# Sieve Of Eratosthenes

Prime numbers are effectively the building blocks of mathematics.  Nearly all mathematical theorems are closely related to prime numbers.  Unfortunately, the distribution (pattern) of the primes is an open problem and may be the most prized unanswered question in mathematics.  Determining whether a number is prime is not difficult but nearly requires an exhaustive search.  Computers are best suited for tackling this problem.  

The sieve of Eratosthenes is an algorithm that identifies all prime numbers less than or equal to a value. 

## Algorithm

Suppose we want to identify all prime numbers less than or equal to a given natural number $n$. Below represents a basic overview of the sieve of Eratosthenes algorithm. 

1. Create a zero indexed array of size $n+1$ filled with boolean values initialized as true.
2. The boolean value in each cell of the array will indicate whether the associated index is prime (true) or composite (false).
3. The index 0 and 1 as false because 0 and 1 are not prime numbers. 
4. Implementing the For Loop
    1. Locate the next value in the array that is marked true.
    2. This value is a prime number and set its index as $P$.
    3. Iterate through the entire array marking indices that are multiples of $P$ as false.  

The result will be an array of boolean values. 
    * True value indicates the associated index is a prime number.
    * False value indicates the associated index is a composite number.


## Example Of Algorithm ($n=40$)

What are all the prime numbers associated with the number 40?

To help make the exercise more readable, we will use values and mark them out. 

$$P = (0,1,2,3,4,...,39,40)$$

The values $0$ and $1$ are not prime so they are marked out.

$$P = (x,x,2,3,4,...,39,40)$$

The first number not marked out is a two. This implies $2$ is a prime number and so multiples of two must be marked out because they can not be prime. 

$$P = (x,x,2,3,x,5,x,7,x,9,x,11,x,13,...39, x)$$

The next number not marked out is 3.  It must be the case that 3 is a prime and so we need to mark out all multiples of 3.

$$P  = (x,x,2,3,x,5,x,7,x,x,x,11,x,13,x,x,x,17,...x, x)$$

The next number not marked out is 5.  It must be the case that 5 is a prime and so we mark out all multiples of 5. This means we only have to mark out 25 and 35 because 5,10,15,20,30, and 40 have already been marked out.

The next number not marked out is 7. All multiples of 7 have already been marked out.

The next number not marked out is 11.  All multiples of 11 have already been marked out.

The next number not marked out is 13.  All multiples of 13 have already been marked out. 

The next number not marked out is 17.  All multiples of 17 have already been marked out. 

The next number not marked out is 19.  All multiples of 19 have already been marked out. 

The next number not marked out is 23. All multiples of 23 have already been marked out.

The next number not marked out is 29. All multiples of 29 have already been marked out.

The next number not marked out is 31.  All multiples of 31 have already been marked out.

The next number not marked out is 37.  All multiples of 37 have already been marked out.

## Identify Patterns To Improve Algorithm 

Notice the following two patterns in the example above.

* The multiple of a prime $P$ that has not been marked out is $P^2$
* All identified primes larger than $\sqrt{40} \approx 6.3246$ did not have multiples removed.

The two facts above are really restaments of each other and are not unique to this example.  They will be true regardless of which value is applied to the algorithm. This implies the algorithm only has to iterate up to the $\sqrt{n}$ and multiple removal can start at $p^2$.

## Sample Code (Python)

Below is example Python code implementing the Sieve of Eratosthenes.

    def sieve_of_eratosthenes(n):
        primes = [True] * (n + 1)
        p = 2
        while p * p <= n:
            if primes[p]:
                for i in range(p * p, n + 1, p):
                    primes[i] = False
            p += 1
        
        prime_numbers = [p for p in range(2, n + 1) if primes[p]]
        return prime_numbers

    n = 40000000
    primes = sieve_of_eratosthenes(n)

    print("List of Prime Numbers Less Than or Equal to", n)
    print(sieve_of_eratosthenes(n))

The Python program above calculates all prime numbers less than or equal to 40 million in less than 5 seconds (commenting out the printing of the primes) on a relatively small computer.  It was not able to complete a request 10 times larger at 400 million. 





